# Mysql基础框架
![](../../img/mysql基础架构.png)
- 连接器： 身份认证和权限相关(登录 MySQL 的时候)。
- 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
- 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- 优化器： 按照 MySQL 认为最优的方案去执行。
- 执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- 插件式存储引擎 ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。

# MySQL 存储引擎架构了解吗？
MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。

# MyISAM和InnoDB
1. 是否支持行级锁
    
    InnoDB支持行级锁和表级锁，默认是行级锁。MyISAM只有表级锁，所以并发InnoDB性能更好。
2. 是否支持事务

   MyISAM不提供事务支持。InnoDB提供事务支持，实现了SQL标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。
3. 是否支持外键

   MyISAM不支持，而InnoDB支持。
4. 是否支持数据库异常崩溃后的安全恢复

   MyISAM不支持，而InnoDB支持。

# 何为事务？
事务是逻辑上的一组操作，要么都执行，要么都不执行。

# 事务特性
1. 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。
2. 一致性（Consistency）： 执行事务前后，数据保持一致。无论是否成功，数据要保持一致。
3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
4. 持久性（Durabilily）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

> A、I、D是手段，C是目的。

# 并发事务带来了哪些问题?
- 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了
这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这
个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，
事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读
数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，
第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

# SQL标准定义了哪些事务隔离级别?

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|read-uncommintted（读未提交）|×|×|×|
|read-committed（读提交）|✔|×|×|
|repeatable-read（可重复度）（默认）|✔|✔|×|
|serializable（串型）|✔|✔|✔|

# MySQL 的隔离级别是基于锁实现的吗？
MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。

SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。

不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。

# 表级锁和行级锁了解吗？有什么区别？
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可
（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比 ：

表级锁： MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定
粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。

行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，
并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

# 使用行级锁需要注意什么
InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者
索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。


# 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：

- 共享锁（S 锁） ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- 排他锁（X 锁） ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条
事务加任何类型的锁（锁不兼容）。

# 意向锁
如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。

- 意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

> 意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

意向锁之间是互相兼容的，意向锁和共享锁和排它锁互斥（**这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥**）。

||IS锁|IX锁|
|---|---|---|
|IS锁|兼容|兼容|
|IX锁|兼容|兼容|

||IS锁|IX锁|
|---|---|---|
|S锁|兼容|互斥|
|X锁|互斥|互斥|

# InnoDB 有哪几类行锁？
MySQL InnoDB 支持三种行锁定方式：
- 记录锁（Record Lock） ：也被称为记录锁，属于单个行记录上的锁。
- 间隙锁（Gap Lock） ：锁定一个范围，不包括记录本身。
- 临键锁（Next-key Lock） ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

# Truncate和delete
truncate:
   - 删除表并重新创建。
   - 重置auto_increment
   - 不知道删除多少行
   - 保留分区

delete:
   - 逐行删除。
   - 不会重置自增值
   - 知道删除行数

# 数据库的备份和还原
```sql
-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database

-- 1.导出一张表
mysqldump -uuser -ppassword databaseName tableName > fileName(D:/temp.sql)
-- 2.导出多张表
mysqldump -uuser -ppassword databaseName tableName1 tableName2 tableName3 > fileName(D:/temp.sql)
-- 3.导出所有表
mysqldump -uuser -ppassword databaseName > fileName(D:/temp.sql)
-- 4.导出数据库
mysqldump -uuser -ppassword --lock-all-tables --database 库名 > fileName(D:/temp.sql)
-- 5.导出所有库
mysqldump -uuser -ppassword --all-database > fileName(D:/temp.sql)
-- 6.条件导出
mysqldump -uuser -ppassword databaseName tableName --where='id=1' > fileName(D:/temp.sql)

-- 导入
-- 1.登录情况下
source 备份文件；
-- 2.直接导入
mysql -uuser -ppassword 库名 < 备份文件；
```

# UNION
## UNION 与 UNION ALL 的区别
当使用 UNION 时，MySQL 会把结果集中重复的记录删掉，而使用 UNION ALL ，MySQL 会把所有的记录返回，且效率高于 UNION

# SQL语言四大类
数据定义语言DDL:
   - 数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等
   - CREATE TABLE/VIEW/INDEX/SYN/CLUSTER
   - **DDL操作是隐性提交的！不能rollback**

数据操纵语言DML:
  - 插入：INSERT
  - 更新：UPDATE
  - 删除：DELETE

数据查询语言DQL:
   - 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。

数据控制语言DCL:
   - 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。

# Mysql如何保证原子性的

事务保证操作的原子性，是在操作过程中产生异常，对已执行的操作进行回滚。在 MySQL 中，恢复机制是通过 回滚日志（undo log） 实现的，
所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子即可！
并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。

# Mysql日志类型（InnoDB）

错误日志（error log）:记录mysql的启动，运行和关闭的日志。
二进制日志（binary log）:记录操作数据的sql。
一般查询日志（general query log）：建立连接的客户端发送的所有sql，默认关闭。
慢查询日志（slow query log）:查询时间超过指定时间的所有查询。
事务日志（redo log/undo log）:重做日志/回滚日志
中继日志（relay log）:类似二进制日志，但是针对的对象是主从的从库。
DDL日志（DDL log）:数据库定义sql日志。




