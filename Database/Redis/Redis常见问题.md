# Redis
1. 是什么

内存数据库，直接将数据保存在内存中，还可以定期将数据持久化到硬盘中。

2. 优点

- 内存操作，新能好。
- 支持多数据结构，value最大1GB容量。
- 多数据结构使redis可做多应用。
- 可为k-v设置过期时间。

3. 缺点

大小受物理内存影响，不适合高数据量读写。

# 与Memcached比较

共同点：
- 都是内存数据库
- 都有过期策略
- 性能都很高

不同点：
- Redis支持多数据结构，Memcached只支持字符串。
- Redis有灾难恢复机制。
- 内存使用完Redis将不常用数据持久化到硬盘，memcached直接报错。
- Redis支持原生集群，Memcached不支持。
- Redis采用单线程和IO多路复用，Memcached是多线程和非阻塞IO。
- Redis支持订阅发布、事务和Lua脚本。
- 定期数据删除，Redis是定期和惰性删除，Memcached是惰性删除。
- Redis性能比Memcached高。
- Redis可以持久化数据。


# Redis支持的数据类型
String、List、Set、Sorted Set、Hashes

# Redis适合场景
1. 会话缓存
2. 全页缓存
3. 队列
4. 排行榜、计数器
5. 发布订阅

# Redisson
是基于Redis的高级分布式框架。

# Redis数据淘汰策略
1. 返回错误当内存到达界限
2. 淘汰不常用key，为新增内容腾出空间
3. 淘汰不常用key，仅在过期key中查找
4. 随机淘汰不常用key
5. 随机淘汰不常用key，仅在过期key中查找

# Redis除缓冲其他作用
1. 分布式锁
2. 限流
3. 消息队列
4. 分布式token

# Redis消息队列
Redis5.0新增Stream数据类型。
- 发布/订阅模式
- 按照消费者组进行消费
- 消息持久化

# String和Hash哪个储存较好
- String是储存序列化后的对象数据，存放的是整个对象。Hash是存放对象的字段，对与经常修改字段或者新增字段存在Hash中较好。
- String储存数据较Hash占用空间较少，性能较高。如果对性能较敏感应用建议使用String。

# 实现随机抽检
使用SET集合：
- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。
- `SRANDMEMBER key count`：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。

# Bitmap实现用户活跃度
可以使用日期当成key，使用用户的ID当成偏移量，对用户活跃状态进行设置。

1. 使用用户的ID当做偏移量，进行设置。
```shell
SETBIT 20221001 10001 1;
SETBIT 20221001 10002 1;
SETBIT 20221002 10001 1;
```
2. 统计两天同时活跃用户。
```shell
# 计算结果
BITOP and desk1 20221001 20221002;
# 统计结果
BITCOUNT desk1;
```
3. 统计两天在线过的用户。
```shell
BITOP or desk2 20221001 20221002;
BITCOUNT desk1;
```

# Redis6.0之前为什么不多线程
在Redis4.0就增加了多线程，只不过是针对大键值对的操作，一些删除，清理数据区的异步操作。

- 单线程编程容易维护也容易
- Redis瓶颈不在CPU而在于内存和网络
- 多线程可能会出现死锁和上下文切换问题，这样会消耗一些性能

# Redis6.0之后为什么使用多线程
Redis6.0 引入多线程主要是为了提高网络 IO 读写性能。虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，
执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

- 默认多线程关闭
- `io-threads-do-reads yes`配置文件开启
- 开启后需要配置线程数：io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程

# 给缓存数据设置过期时间作用
- Redis用的是内存，不过期很容易造成内存溢出。
- 可以用于验证码，验证短信或用户登录token等易过期信息。

# 缓存雪崩
缓存雪崩：

- 缓存用于减缓请求对数据库的压力，如果缓存宕机或者大面积key不存在，这会导致所有请求就会直接请求到数据库中，数据库压力剧增可能会宕机。

解决办法：

    1. 缓冲做高可用（集群），防止宕机
    2. 使用断路器，如果缓存宕机，对请求进行限流防止请求全部到DB上，保证一部分请求继续可用，其余部分回复默认值。
    3. key失效时间随机

# 缓存穿透
缓存穿透：

    1. 大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层，这样DB有可能承受不了导致宕机。
    2. 大量请求查询刚失效的一个Key，这样也会导致请求都会到DB上，导致DB宕机。

解决办法：

    1. 使用占位符，查询时检测是否为占位符，如果是将直接返回，不进行DB数据库查询。可能会被恶意攻击，造成大量占位符key，即使设置了key过期时间。
    2. 布隆过滤。类似为所有的key设置一个目录，这个目录使用的是哈希，这可能会导致误判（哈希冲突）。

![](../../img/redis-bulong.png)


# 缓存并发竞争
并发竞争：
- 多个客户端同时对同一个key进行操作，由于顺序的不同，导致数据的错误。

解决办法：
- 加分布式锁，同时加入数据时间戳。抢锁再进行数据时间戳对比，判断是否操作。


# Redis事务的原子性
Redis的事务是对命令进行打包，然后一下全部执行。除了错误命令，其他都会执行，并且不支持回滚。所以Redis的事务不支持原子性，而且持久性也是。

# Redis的事务另一种方法Lua脚本
可以使用Lua脚本来类似事务执行Redis命令，这样可以减少网络开销。Lua脚本也并不能保证原子性，中途出错之前执行的命令无法撤回。所以Lua脚本也无法保证原子性。


# Redis性能优化

## bigkey
当一个key对应的value值比较大的时候，这时的key就成了bigkey。具体的大小并不确切。key的value达到10k就算bigkey，混合类型并不适合越多就是bigkey。

## bigkey危害
- 消耗更多的内存
- 对服务器的性能有较大影响

## 如何查找bigkey
Redis自带的查找参数`--bigkey`，只会找到每种类型第一的key，对性能有所影响。

## 大量key集中过期
解决方案：
1. 设置随机过期时间
2. 开启惰性删除


# 3种常见读写策略
## 1. 旁路读写策略
写：
- 读取redis数据更新DB
- 删除redis数据

读：
- 从redis直接读取数据，有直接返回
- 从redis读不到数据，从db读取数据返回
- 再把db数据写入redis中

缺点：
- 写时候可能会导致数据不一致问题
- 写比较频繁的话，redis中数据被频繁删除，影响数据的命中。

解决：
- 数据强制场景：同时更新db数据和redis数据，不过需要添加分布式锁。
- 数据不强制场景：为key设置较短失效时间，这样数据一致性影响较少。

## 2.读写穿透
写：
- 先查redis，redis中不存在，直接更新db
- redis中存在，直接更新redis，然后redis服务同步到db

读：
- 从redis中直接读取返回
- 读取不到，从db中加载，写到redis中后返回

## 3. 异步缓存写入
只更新redis，不与db关联。







