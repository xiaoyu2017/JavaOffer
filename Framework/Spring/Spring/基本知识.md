# 1. 概述

> Spring是整合框架、简化开发的框架，主要的技术为IOC、DI、AOP和事务等。可以理解为它是一个管家，管理者项目中的对象，集精华框架不重复造轮子。

框架架构图：

![](../../img/spring0.png)

# 2. 简单入门

## 2.1 IOC

> IOC称之为控制反转，大致的意思是将项目中有自己来维护的对象创建由Spring进行来创建管理，自己维护时是用什么创建什么，现在是需要什么就直接从容器中拿什么。

示例：
1. 创建项目，添加核心依赖：
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.10.RELEASE</version>
</dependency>
```

2. 创建需要管理类：
```java
public interface UserDao {
    void save();
}

public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("UserDao save run");
    }
}

public interface UserService {
    void add();
}

public class UserServiceImpl implements UserService {

    private UserDao userDao = new UserDaoImpl();

    public void add() {
        userDao.save();
        System.out.println("UserService add run...");
    }
}
```

3. 创建配置文件：

application.xml
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl"/>

</beans>
```

4. 使用容器获得类：
```java
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserService userService = (UserService) context.getBean("userService");
        userService.add();
    }
}
```

## 2.2 DI
> 类之间可能存在依赖，DI技术会把需要的依赖一并纳入容器管理。

1. 修改`UserServiceImpl`类
```java
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println("UserService add run...");
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

2. 配置依赖关系
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--配置需要管理的类
        id：唯一标识
        class：类的全路径名
    -->
    <bean id="userDao" class="cn.fishland.dao.impl.UserDaoImpl"/>

    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl">
        <!--设置属性
            name：属性名称
            ref：关联的类（其他配置类id）
        -->
        <property name="userDao" ref="userDao"/>
    </bean>

</beans>
```

3. 调用
```java
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserService userService = (UserService) context.getBean("userService");
        userService.add();
    }
}
```

# 3. IOC和Bean

> 在Spring中每个类对象被称为Bean，Bean通过一系列的属性配置，容器可以通过一些列配置信息进行管理。

```xml
<beans>
    <bean .../>
    <bean .../>
    ...
</beans>
```
## 3.1 基础属性

### 3.1.1 id

> bean的唯一标识，主要用于bean查找。
```xml
<beans>
    <bean id="userDao" .../>
    <bean id="userService" .../>
    ...
</beans>
```

### 3.1.2 class

> bean需要实例化类的全路径名

```xml
<beans>
    <bean id="userDao" class="cn.fishland.dao.impl.UserDaoImpl"/>
    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl" />
    ...
</beans>
```

### 3.1.3 name

> 为bean起的别名，引用bean也可以通过name中名称完成，多个name名称可以通过逗号（,）分号（;）和空格来实现

```xml
<beans>
    <bean id="userDao" class="cn.fishland.dao.impl.UserDaoImpl" name="dao ud"/>
    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl" name="service us">
        <!--可以引用别名-->
        <property name="userDao" ref="dao"/>
    </bean>
    ...
</beans>
```

### 3.1.4 scope

> bean的作用范围，表示bean是单例还是多例。可选值为singleton和prototype。bean默认是单例的，所以可能出现线程安全问题。所以容器中管理的对象一般
> 为无状态类，此类不存储数据。例如表现层，服务层，数据层，工具类。

```xml
<beans>
    <!--单例对象-->
    <bean id="userDao" class="cn.fishland.dao.impl.UserDaoImpl" name="dao ud" scope="singleton"/>
    <!--多例对象-->
    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl" name="service us" scope="prototype">
        <!--可以引用别名-->
        <property name="userDao" ref="dao"/>
    </bean>
    ...
</beans>
```

## 3.2 bean实例化

> 容器通过配置就可以实例化类，它是通过构造方法进行类的创建，也可以通过bean配置来改变示例化方式。总结有三种方式来实例化构造方法、静态工厂和实例工厂。

### 3.2.1 构造方法

1. 准备的类
```java
public class UserDaoImpl implements UserDao {
    // 构造函数权限为private，Spring还是可以实力化对象的
    public UserDaoImpl() {
        System.out.println("UserDaoImpl init...");
    }

    public void save() {
        System.out.println("UserDao save run");
    }
}
```

2. 配置bean

`<bean id="userDao" class="cn.fishland.dao.impl.UserDaoImpl"/>`

3. 测试
```java
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserDao userDao = (UserDao) context.getBean("userDao");
        userDao.save();
    }
}
```

**_通过以上控制台显示可以看出是调用构造函数，但是当我们把构造函数权限变成私private有也是可以实例化对象的。_**
这是因为Spring是通过反射来实现初始化的。但是类必须有无参构造函数，否则无法实例化。

### 3.2.2 静态工厂

> 用工厂类来实现类的实例化

```java
public class UserDaoFactory {
    public static UserDao userDao() {
        // 实例化前一些必须操作
        System.out.println("init UserDao pre work...");
        return new UserDaoImpl();
    }
}
```

配置：
```xml
<bean id="userDao" class="cn.fishland.tool.UserDaoFactory" factory-method="userDao"/>
```

### 3.2.3 实例化工厂

> 通过工厂实例化bean与静态工厂不同的是需要先实例化工厂才可以使用。

1. 实例化工厂实现

类：
```java
public interface BookDao {
    void show();
}

public class BookDaoImpl implements BookDao {

    public BookDaoImpl() {
        System.out.println("BookDao init...");
    }

    public void show() {
        System.out.println("BookDao run...");
    }
}
```
工厂类：
```java
public class BookDaoFactory {
    private BookDao bookDao() {
        return new BookDaoImpl();
    }
}
```

配置：
```xml
<beans>
    <bean id="bookDaoFactory" class="cn.fishland.tool.BookDaoFactory"/>
    <bean id="bookDao" class="cn.fishland.dao.impl.BookDaoImpl" factory-bean="bookDaoFactory" factory-method="bookDao"/>
</beans>
```

测试：
```java
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        BookDao bookDao = (BookDao) context.getBean("bookDao");
        bookDao.show();
    }
}
```

2. 实现FactoryBean创建实例化工厂

创建工程类：
```java
public class BookDaoFactoryBean implements FactoryBean<BookDao> {
    /** 获得实例化对象 */
    public BookDao getObject() throws Exception {
        return new BookDaoImpl();
    }

    /** 实例化对象类型 */
    public Class<?> getObjectType() {
        return null;
    }

    /** 是否为单例 */
    public boolean isSingleton() {
        return true;
    }
}
```

配置文件：
```xml
<!--如此简单-->
<bean id="bookDaoBean" class="cn.fishland.tool.BookDaoFactoryBean"/>
```


## 3.3 bean生命周期

> 生命周期即bean从创建到销毁的过程，在整个过程都干了什么事（执行了哪些方法以便于我们自己实现来进行修改）。

1. 简单实现

类：
```java
public interface MenuDao {
    void save();
}

public class MenuDaoImpl implements MenuDao {
    public MenuDaoImpl() {
        System.out.println("MenuDaoImpl construct...");
    }

    public void save() {
        System.out.println("MenuDaoImpl save run...");
    }

    public void init() {
        System.out.println("MenuDaoImpl init...");
    }

    public void destory() {
        System.out.println("MenuDaoImpl destory...");
    }
}
```

配置：`<bean id="menuDao" class="cn.fishland.dao.impl.MenuDaoImpl" init-method="init" destroy-method="destory"/>`

测试：
```java
public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        MenuDao menuDao = (MenuDao) context.getBean("menuDao");
        menuDao.save();
        // 关闭容器
        context.close();
    }
}
```

> 执行顺序构造、init、destory

2. 通过实现接口简化配置

> 实现接口InitializingBean完成afterPropertiesSet方法，为bean的init-method。实现接口DisposableBean完成destroy方法，为bean的destroy-method

类：
```java
public class MenuDaoImpl implements MenuDao, InitializingBean, DisposableBean {
    public MenuDaoImpl() {
        System.out.println("MenuDaoImpl construct...");
    }

    public void save() {
        System.out.println("MenuDaoImpl save run...");
    }

    /** destroy方法 */
    public void destroy() throws Exception {
        System.out.println("MenuDaoImpl destroy...");
    }

    /** init方法 */
    public void afterPropertiesSet() throws Exception {
        System.out.println("MenuDaoImpl afterPropertiesSet...");
    }
}
```

配置：

`<bean id="menuDao" class="cn.fishland.dao.impl.MenuDaoImpl"/>`

测试：
```java
public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        MenuDao menuDao = (MenuDao) context.getBean("menuDao");
        menuDao.save();
        // 关闭容器
        context.close();
    }
}
```

**总结：** bean的生命周期
1. 创建对象
2. 调用构造
3. 执行setter
4. 执行bean的init
5. 使用bean执行业务方法
6. 关闭销毁执行bean销毁方法

# 4. DI

> DI称为依赖注入，就是通过配置将类属性进行设置。依赖注入分为两种setter和构造方法，注入的内容为引用类型和基础数据类型。

## 4.1 setter

### 4.2.1 注入引用数据类型
类：
```java
public interface UserDao {
    void save();
}

public class UserDaoImpl implements UserDao {
    public UserDaoImpl() {
        System.out.println("UserDaoImpl init...");
    }

    public void save() {
        System.out.println("UserDao save run");
    }
}

public interface UserService {
    void add();
}

public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println("UserService add run...");
    }

    // 需要添加属性set方法
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

配置信息：
```xml
<beans>
    <bean id="userDao" class="cn.fishland.tool.UserDaoFactory" factory-method="userDao"/>

    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl">
        <!--设置属性
            name：属性名称
            ref：关联的类（其他配置类id）
        -->
        <property name="userDao" ref="userDao"/>
    </bean>
</beans>
```

测试：
```java
public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserService userService = (UserService) context.getBean("userService");
        userService.add();
        // 关闭容器
        context.close();
    }
}
```

### 4.2.1 注入基础数据类型

类：
```java
public interface TagDao {
    void show();
}

public class TagDaoImpl implements TagDao {
    private String name;
    private String flag;

    public void show() {
        System.out.println("TagDaoImpl show... name=" + name + " flag=" + flag);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setFlag(String flag) {
        this.flag = flag;
    }
}
```

配置：
```xml
<bean id="tagDao" class="cn.fishland.dao.impl.TagDaoImpl">
    <!--
        name：需要注入的属性名称
        value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
    -->
    <property name="name" value="fish"/>
    <property name="flag" value="1"/>
</bean>
```

测试：
```java
public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        TagDao tagDao = (TagDao) context.getBean("tagDao");
        tagDao.show();
        // 关闭容器
        context.close();
    }
}
```

## 4.2 构造注入

### 4.2.1 引用类型注入

类：
```java
public interface TagService {
    void add();
}

public class TagServiceImpl implements TagService {

    private TagDao tagDao;

    public TagServiceImpl(TagDao tagDao) {
        this.tagDao = tagDao;
    }

    public void add() {
        tagDao.show();
        System.out.println("TagServiceImpl add...");
    }
}
```

配置：
```xml
<bean>
    <bean id="tagDao" class="cn.fishland.dao.impl.TagDaoImpl">
        <!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        -->
        <property name="name" value="fish"/>
        <property name="flag" value="1"/>
    </bean>

    <bean id="tagService" class="cn.fishland.service.impl.TagServiceImpl">
        <constructor-arg name="tagDao" ref="tagDao"/>
    </bean>
</bean>
```

测试：
```java
public class Application {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        TagService tagService = (TagService) context.getBean("tagService");
        tagService.add();
        // 关闭容器
        context.close();
    }
}
```

### 4.2.2 基础数据类型

```java
public class TagServiceImpl implements TagService {

    private TagDao tagDao;
    private String name;
    private Integer flag;

    public TagServiceImpl(TagDao tagDao) {
        this.tagDao = tagDao;
    }

    public TagServiceImpl(TagDao tagDao, String name, Integer flag) {
        this.tagDao = tagDao;
        this.name = name;
        this.flag = flag;
    }

    public void add() {
        tagDao.show();
        System.out.println("TagServiceImpl add...");
        System.out.println("TagServiceImpl name=" + name);
        System.out.println("TagServiceImpl flag=" + flag);
    }
}
```

配置：方式一
```xml
<beans>
    <bean id="tagDao" class="cn.fishland.dao.impl.TagDaoImpl">
        <!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        -->
        <property name="name" value="fish"/>
        <property name="flag" value="1"/>
    </bean>

    <bean id="tagService" class="cn.fishland.service.impl.TagServiceImpl">
        <!--
            name:为形参的名称
        -->
        <constructor-arg name="tagDao" ref="tagDao"/>
        <constructor-arg name="name" value="fish"/>
        <constructor-arg name="flag" value="1"/>
    </bean>
</beans>
```

配置：方式二，主要输解决构造方法形参名称改变导致的一些列问题
```xml
<beans>
    <bean id="tagDao" class="cn.fishland.dao.impl.TagDaoImpl">
        <!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        -->
        <property name="name" value="fish"/>
        <property name="flag" value="1"/>
    </bean>

    <bean id="tagService" class="cn.fishland.service.impl.TagServiceImpl">
        <!--
            type：为形参的数据类型，当存在相同数据类型就会出现问题
        -->
        <constructor-arg type="cn.fishland.dao.TagDao" ref="tagDao"/>
        <constructor-arg type="java.lang.String" value="fish"/>
        <constructor-arg type="java.lang.Integer" value="1"/>
    </bean>
</beans>
```

配置：方式三，解耦又可以避免相同类型问题
```xml
<beans>
    <bean id="tagDao" class="cn.fishland.dao.impl.TagDaoImpl">
        <!--
            name：需要注入的属性名称
            value：注入的值，spring会自动类型转换，需要确保在转换中不会出错。
        -->
        <property name="name" value="fish"/>
        <property name="flag" value="1"/>
    </bean>

    <!--
        index：形参的位置，从0开始
    -->
    <bean id="tagService" class="cn.fishland.service.impl.TagServiceImpl">
        <constructor-arg index="0" ref="tagDao"/>
        <constructor-arg index="1" value="fish"/>
        <constructor-arg index="2" value="1"/>
    </bean>
</beans>
```
## 4.3 自动装配

> 前面两种方式都较麻烦，需要大量的配置文件，Spring还提供了自动装配设置，更为简单。IOC容器会根据一些条件自动在容器中寻找符合条件的依赖bean。
> 装配的条件为按照类型、按照名称。

1. 按类型注入

**自动装配必须条件：**
1. 被注入类必须在容器管理中
2. 注入属性需要有setter方法
3. 容器中存在多个相同类型按照类型注入就会失败

```java
public class UserDaoImpl implements UserDao {
    public UserDaoImpl() {
        System.out.println("UserDaoImpl init...");
    }

    public void save() {
        System.out.println("UserDao save run");
    }
}

public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void add() {
        userDao.save();
        System.out.println("UserService add run...");
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

```xml
<beans>
    <bean class="cn.fishland.tool.UserDaoFactory" factory-method="userDao"/>
    <!--
        autowire；开启自动装配，byType表示根据类型装配
    -->
    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl" autowire="byType" />
</beans>
```


2. 按名称注入

> 存在一个问题，当容器存在多个相同类型，就会导致装配失败，这时可以使用根据名称装配。按照名称注入如果容器找不到对应的类就会注入null

名称：指的是注入setter方法去掉set后首字母小写名称，按照默认set规则，最后的结果就是属性名称。

```xml
<beans>
    <bean id="userDao" class="cn.fishland.tool.UserDaoFactory" factory-method="userDao"/>
    <!--
        byName：开启根据名称注入
    -->
    <bean id="userService" class="cn.fishland.service.impl.UserServiceImpl" autowire="byName" />
</beans>
```

_**总结：**_
1. 自动装配适用于引用类型，不适用基础数据类型
2. 按照类型装配需要确保容器中只有一个类型的bean
3. 按照名称注入耦合较大
4. 自动装配优先级低于setter和构造方法配置注入，同时存在自动装配失效

## 4.4 集合注入

```java
public class CollectionDaoImpl implements CollectionDao {

    private int[] array;
    private List<String> list;
    private Set<String> set;
    private Map<String, String> map;
    private Properties properties;

    public void showData() {
        System.out.println("CollectionDaoImpl showData...");
        System.out.println("CollectionDaoImpl array=" + Arrays.toString(array));
        System.out.println("CollectionDaoImpl list=" + list);
        System.out.println("CollectionDaoImpl set=" + set);
        System.out.println("CollectionDaoImpl map=" + map);
        System.out.println("CollectionDaoImpl properties=" + properties);

    }

    public void setArray(int[] array) {
        this.array = array;
    }

    public void setList(List<String> list) {
        this.list = list;
    }

    public void setSet(Set<String> set) {
        this.set = set;
    }

    public void setMap(Map<String, String> map) {
        this.map = map;
    }

    public void setProperties(Properties properties) {
        this.properties = properties;
    }
}
```

```xml
<bean id="collectionDao" class="cn.fishland.dao.impl.CollectionDaoImpl">
    <property name="array">
        <array>
            <value>1</value>
            <value>2</value>
            <value>3</value>
        </array>
    </property>
    <property name="list">
        <list>
            <value>itcast</value>
            <value>itheima</value>
            <value>boxuegu</value>
            <value>chuanzhihui</value>
        </list>
    </property>
    <property name="set">
        <set>
            <value>itcast</value>
            <value>itheima</value>
            <value>boxuegu</value>
            <value>boxuegu</value>
        </set>
    </property>
    <property name="map">
        <map>
            <entry key="country" value="china"/>
            <entry key="province" value="henan"/>
            <entry key="city" value="kaifeng"/>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="country">china</prop>
            <prop key="province">henan</prop>
            <prop key="city">kaifeng</prop>
        </props>
    </property>
</bean>
```

# 5. 配置第三方Bean

配置Druid数据库连接池:

1. 引依赖
```xml
<dependencies>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.2.15</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.30</version>
    </dependency>
</dependencies>
```

2. 配置
```xml
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:33060/BookManager"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```


3. 测试
```java
public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        DataSource dataSource = (DataSource) context.getBean("dataSource");
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        // 关闭容器
        context.close();
    }
}
```

配置C3p0数据库连接池:

配置：
```xml
<bean id="dataSourceC3p0" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:33060/BookManager"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
    <property name="maxPoolSize" value="1000"/>
</bean>
```

# 6. 加载properties文件

1. 添加properties文件

jdbc.properties
```properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:33060/BookManager
jdbc.username=root
jdbc.password=root
```

2. 添加context命名空间
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            <!--新增-->
            http://www.springframework.org/schema/context
            <!--新增-->
            http://www.springframework.org/schema/context/spring-context.xsd"
        <!--新增-->
       xmlns:context="http://www.springframework.org/schema/context">
    
</beans>
```

3. 配置添加properties文件
```xml
<beans>
    <!--加载本地文件-->
    <context:property-placeholder location="jdbc.properties"/>
</beans>
```

4. 引用properties属性
```xml
<!--使用${}来获得内容-->
<bean id="dataSourceC3p0" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="user" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
    <property name="maxPoolSize" value="1000"/>
</bean>
```

5. 测试
```java
public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        DataSource dataSource = (DataSource) context.getBean("dataSourceC3p0");
        System.out.println(dataSource);
        // 关闭容器
        context.close();
    }
}
```

_**注意：**_
1. 本地的username与环境变量冲突

在加载jdbc.properties文件的时候，也会加载系统环境变量。本地与系统发生冲突后，系统优先。

```java
public class Application {
    public static void main(String[] args) throws SQLException {
        /*此方法可以查看系统环境变量*/
        Map<String, String> env = System.getenv();
        System.out.println(env);
    }
}
```

可以配置`system-properties-mode="NEVER"`表示不加载系统环境变量

2. 加载多个文件

```xml
<beans>
    <!--
        在location中配置多个文件名，中间用逗号隔开
    -->
    <context:property-placeholder location="jdbc.properties,jdbc2.properties" system-properties-mode="NEVER"/>
    <!--
        *.properties：表示所有以properties结尾的文件都会被加载
    -->
    <context:property-placeholder location="*.properties" system-properties-mode="NEVER"/>
    <!--
        classpath:*.properties：项目根目录下所有properties文件都会被加载
    -->
    <context:property-placeholder location="classpath:*.properties" system-properties-mode="NEVER"/>
    <!--
        classpath*:*.properties：项目加项目依赖所有的properties文件
    -->
    <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>
</beans>
```


# 7. 核心容器

## 7.1 容器创建

> 容器主要有两种：ClassPathXmlApplicationContext和FileSystemXmlApplicationContext

```java
public class Application {
    public static void main(String[] args) throws SQLException {
        /*
         * 类翻译过来的意思就是类路径下XML配置文件，所以参数就是类路径下xml文件
         * */
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");

        /*
         * 文件系统下的XML配置文件，配置文件在项目的文件系统下
         * */
        FileSystemXmlApplicationContext context1 = new FileSystemXmlApplicationContext("D:\\XXX\\XX\\X\\application.xml");
    }
}
```

## 7.2 Bean获得

> 获得bean有三种方式

```java
public class Application {
    public static void main(String[] args) throws SQLException {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        // 通过bean的id获得
        BookDao bookDao = (BookDao) context.getBean("bookDao");
        // 通过名称获得，并且给出结果的类型，免除强制类型转换       
        BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
        // 直接通过类型获得，这种方法存在一些局限性，确保容器中只有一个这种类型实例
        BookDao bookDao = ctx.getBean(BookDao.class);
    }
}
```

## 7.3 BeanFactory










# 常见异常

1. NoSuchBeanDefinitionException：引用未定义的bean






