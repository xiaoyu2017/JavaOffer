# 悲观锁
概念：对于并发数据，悲观锁使用数据的时候认为一定会有其他线程来修改数据，在修改前会先给数据添加锁，然后再进行数据修改。
优点：很好保证数据的同步性。
缺点：资源消耗较多，每次都会进行加解锁操作。
使用场景：适用于写较多场景。

# 乐观锁
概念：对于并发数据，乐观锁任务在自己修改数据的时候，不会有其他线程对数据进行修改。不加锁直接对数据进行更新，进行写入时再进行判断选择更新策略。
优点：通过相关算法（CAS）进行值更新，资源消耗少，性能较好。
缺点：数据同步可能存在问题。
使用场景：适用于读较多场景。

# 自旋锁
概念：当被加锁操作代码消耗时间较短时，这时多线程进行锁竞争时会造成线程切换的资源浪费（挂起和唤醒都需要消耗资源），这时就不让线程进行阻塞，而是进行无意义循环，
等待锁的获得，这就是自旋锁。
优点：减少线程切换资源消耗。
缺点：导致线程等待时间过长或者自旋线程较多，占用过多的CPU时间。
使用场景：被加锁代码等待时间较短。

# 自适应自旋锁
概念：是对自旋锁的优化，自旋的次数和时间不定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获
得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很
少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

# 偏向锁、轻量级锁，重量级锁

[synchronized锁升级](./Java并发.md)

概念：
优点：
缺点：
使用场景：