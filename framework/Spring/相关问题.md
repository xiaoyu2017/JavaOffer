# 什么是Spring
Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地
协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转）和
AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集
成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java应用程序的开发。

# spring包括的模块
spring4:

![](../../img/spring4framework.png)

spring5:

![](../../img/spring5framework.png)

**_5版本移除portlet，新增webflux模块_**

spring各模块依赖关系图：

![](../../img/springfrmeworklib.png)

## Core Container
- spring-core ：Spring 框架基本的核心工具类。
- spring-beans ：提供对 bean 的创建、配置和管理等功能的支持。
- spring-context ：提供对国际化、事件传播、资源加载等功能的支持。
- spring-expression ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。

## AOP
- spring-aspects ：该模块为与AspectJ的集成提供支持。
- spring-aop ：提供了面向切面的编程实现。
- spring-instrument ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为Tomcat传递类文件，就像这些
文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。

## Data Access/Integration
- spring-jdbc ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。
- spring-tx ：提供对事务的支持。
- spring-orm ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。
- spring-oxm ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。
- spring-jms : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。

## Web
- spring-web ：对 Web 功能的实现提供一些最基础的支持。
- spring-webmvc ： 提供对 Spring MVC 的实现。
- spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。
- spring-webflux ：提供对WebFlux的支持。WebFlux是Spring Framework 5.0中引入的新的响应式框架。与Spring MVC不同，它不需要Servlet API，是完全异步。

## Message
- spring-messaging 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。

## Test
Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。

Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法
模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。

# spring, spring mvc, sprong boot之间的区别
spring：提供核心支持，spring-core是框架的核心其他模块基本上都依赖此模块。
spring mvc：spring的一个模块，可以快速构建javaWeb项目，将逻辑，数据和显示分开进行开发（MVC）。
springboot：简化配置，开箱即用。

# Spring IoC

## 将类加到容器中的注解
- @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
- @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
- @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

## @Component和@Bean区别
- @Componentz注解类，@Bean注解方法
- @Bean自定义性强，可以加载第三方类到容器中。@Component就不行。

## 注入Bean注解
spring注解：@Autowired
jdk注解：@Resource，@Inject

## @Autowired和@Resource
@Autowired：spring内置注解，默认byType注入，需要名称注入最好搭配@Qualifier。
@Resource：jdk注解，默认byName注入，可使用name属性进行配置。

## spring中Bean的作用域
- singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。
- prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。
- request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
- session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。
- application/global-session （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。
- websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。

## Bean是线程安全的吗
不是，但是大部分Bean都是无状态的，没有共享属性。如果需要存储值可以使用ThreadLocal。

## Bean生命周期
- Bean 容器找到配置文件中 Spring Bean 的定义。
- Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。
- 如果涉及到一些属性值 利用 set()方法设置一些属性值。
- 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。
- 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。
- 如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。
- 与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。
- 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法
- 如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。
- 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
- 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法
- 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
- 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

![](../../img/bean-live.jpeg)

# Spring AOP
AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）
封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

专业术语：

|术语|含义|
|---|---|
|目标(Target)|被通知的对象|
|代理(Proxy)	|向目标对象应用通知之后创建的代理对象|
|连接点(JoinPoint)|目标对象的所属类中，定义的所有方法均为连接点|
|切入点(Pointcut)|被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）|
|通知(Advice)|增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情|
|切面(Aspect)|切入点(Pointcut)+通知(Advice)|
|Weaving(织入)|将通知应用到目标对象，进而生成代理对象的过程动作|

## Spring AOP和AspectJ AOP区别
Spring AOP属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。
Spring AOP已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是
Spring AOP相对来说更简单，两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。

## AspectJ定义的通知
- Before（前置通知）：目标对象的方法调用之前触发
- After （后置通知）：目标对象的方法调用之后触发
- AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
- AfterThrowing（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。
- Around：（环绕通知）around可以翻译成到处,向各处。编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

## 多切面执行顺序控制
1.@Order(1)注解，数值越小优先级越高。
2.实现Ordered 接口重写 getOrder 方法。
```java
@Component
@Aspect
public class LoggingAspect implements Ordered {

    // ....

    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
```

